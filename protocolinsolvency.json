[{"contract":"0x366049d336e73cfaf39c6a933780ca4c96ea084c","contract_name":"Pool4","sol_function":"function borrow(uint256 amount, uint256 maxRate, uint256 propTokenId) public {\n        //for v2 require this address is approved to transfer propToken \n        require(PropToken0(propTokenContractAddress).getApproved(propTokenId) == address(this), \"pool not approved to move egg\");\n        //also require msg.sender is owner of token\n        require(PropToken0(propTokenContractAddress).ownerOf(propTokenId) == msg.sender, \"msg.sender not egg owner\");\n\n        //check the requested interest rate is still available\n        uint256 fixedInterestRate = uint256(PoolUtils0(poolUtilsAddress).getInterestRate(amount));\n        require(fixedInterestRate \u003c= maxRate, \"interest rate no longer avail\");\n\n        //require the propToken approved has a lien value less than or equal to the requested loan size\n        uint256 lienAmount = PropToken0(propTokenContractAddress).getLienValue(propTokenId);\n        require(lienAmount \u003e= amount, \"loan larger that egg value\");\n\n        //require that LTV of propToken is less than LTV required by oracle\n        uint256 LTVRequirement = LTVGuidelines(LTVOracleAddress).getMaxLTV();\n        (, , uint256[] memory SeniorLiens, uint256 HomeValue, , ,) = PropToken0(propTokenContractAddress).getPropTokenData(propTokenId);\n        for (uint i = 0; i \u003c SeniorLiens.length; i++) {  \n            lienAmount = lienAmount.add(SeniorLiens[i]);\n        }\n        require(lienAmount.mul(100).div(HomeValue) \u003c LTVRequirement, \"LTV too high\");\n\n\n        //first take the propToken\n        PropToken0(propTokenContractAddress).safeTransferFrom(msg.sender, address(this), propTokenId);\n\n        //create new Loan\n        Loan memory newLoan = Loan(loanCount, msg.sender, fixedInterestRate, amount, 0, block.timestamp);\n        loans.push(newLoan);\n        userLoans[msg.sender].push(loanCount);\n\n        //map new loanID to Token ID\n        loanToPropToken[loanCount] = propTokenId;\n\n        //update system variables\n        loanCount = loanCount.add(1);\n        poolBorrowed = poolBorrowed.add(amount);\n\n        //finally move the USDC\n        IERC20Upgradeable(ERCAddress).transfer(msg.sender, amount);\n\n        //then mint HC_Pool for the servicer (fixed 1% origination is better than standard 2.5%)\n        mintProportionalPoolTokens(servicer, amount.div(100));\n    }","sol_instruction":"PropToken0(propTokenContractAddress).safeTransferFrom(msg.sender, address(this), propTokenId)","sol_instruction_end_column":102,"sol_instruction_lines":[261],"sol_instruction_start_column":9,"value":0},{"contract":"0x366049d336e73cfaf39c6a933780ca4c96ea084c","contract_name":"Pool4","sol_function":"function borrow(uint256 amount, uint256 maxRate, uint256 propTokenId) public {\n        //for v2 require this address is approved to transfer propToken \n        require(PropToken0(propTokenContractAddress).getApproved(propTokenId) == address(this), \"pool not approved to move egg\");\n        //also require msg.sender is owner of token\n        require(PropToken0(propTokenContractAddress).ownerOf(propTokenId) == msg.sender, \"msg.sender not egg owner\");\n\n        //check the requested interest rate is still available\n        uint256 fixedInterestRate = uint256(PoolUtils0(poolUtilsAddress).getInterestRate(amount));\n        require(fixedInterestRate \u003c= maxRate, \"interest rate no longer avail\");\n\n        //require the propToken approved has a lien value less than or equal to the requested loan size\n        uint256 lienAmount = PropToken0(propTokenContractAddress).getLienValue(propTokenId);\n        require(lienAmount \u003e= amount, \"loan larger that egg value\");\n\n        //require that LTV of propToken is less than LTV required by oracle\n        uint256 LTVRequirement = LTVGuidelines(LTVOracleAddress).getMaxLTV();\n        (, , uint256[] memory SeniorLiens, uint256 HomeValue, , ,) = PropToken0(propTokenContractAddress).getPropTokenData(propTokenId);\n        for (uint i = 0; i \u003c SeniorLiens.length; i++) {  \n            lienAmount = lienAmount.add(SeniorLiens[i]);\n        }\n        require(lienAmount.mul(100).div(HomeValue) \u003c LTVRequirement, \"LTV too high\");\n\n\n        //first take the propToken\n        PropToken0(propTokenContractAddress).safeTransferFrom(msg.sender, address(this), propTokenId);\n\n        //create new Loan\n        Loan memory newLoan = Loan(loanCount, msg.sender, fixedInterestRate, amount, 0, block.timestamp);\n        loans.push(newLoan);\n        userLoans[msg.sender].push(loanCount);\n\n        //map new loanID to Token ID\n        loanToPropToken[loanCount] = propTokenId;\n\n        //update system variables\n        loanCount = loanCount.add(1);\n        poolBorrowed = poolBorrowed.add(amount);\n\n        //finally move the USDC\n        IERC20Upgradeable(ERCAddress).transfer(msg.sender, amount);\n\n        //then mint HC_Pool for the servicer (fixed 1% origination is better than standard 2.5%)\n        mintProportionalPoolTokens(servicer, amount.div(100));\n    }","sol_instruction":"IERC20Upgradeable(ERCAddress).transfer(msg.sender, amount)","sol_instruction_end_column":67,"sol_instruction_lines":[276],"sol_instruction_start_column":9,"value":0}]